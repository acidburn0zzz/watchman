#!/usr/bin/env bash
# Copyright (c) 2012 fbt <fbt@fleshless.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 	- Redistributions of source code must retain the above copyright notice, 
#		this list of conditions and the following disclaimer.
# 	- Redistributions in binary form must reproduce the above copyright notice,
#		this list of conditions and the following disclaimer in the
#		documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

watchman.usage() {
	echo "Usage: watchman <service> <action>"
}

[[ "$UID" == '0' ]] && {
	flag_system='1'
} || {
	flag_user='1'
}

while getopts "suh" option; do
	case "$option" in
		s) flag_system='1';;
		u) flag_user='1';;
		h|*) watchman.usage; exit 77;;
	esac
done

[[ "$OPTIND" ]] && { shift "$[OPTIND-1]"; }

# Config

[[ "$flag_user" ]] && {
	cfg_cfgdir="$HOME/.watchman"
    cfg_tmpdir="/tmp/$USER/watchman"
}

[[ "$flag_system" ]] && {
	cfg_cfgdir='/etc/watchman'
	cfg_tmpdir='/tmp/watchman'
}

cfg_rundir="$cfg_tmpdir/run"
cfg_initdir="$cfg_cfgdir/init.d"
cfg_logdir="$cfg_tmpdir/log"

# Functions

watchman.msg() { echo "[watchman] $1"; }
watchman.err() { watchman.msg "(error) $1"; }

watchman.die() { exit "$1"; }
watchman.cleanup() { true; } # Placeholder

watchman.init() {
	for i in "${cfg_tmpdir}" "$cfg_rundir" "$cfg_logdir" "${cfg_cfgdir}" "$cfg_initdir"; do
		[[ -d "$i" ]] || {
			watchman.msg "$i does not exist, attempting to create..."
			mkdir -p "$i" && {
				watchman.msg "Success!"
			} || {
				watchman.err "Can't create $i, exiting"
				watchman.die 9
			}
		}
	done
}

watchman.start() {
	watchman.status && {
		watchman.err "$sname is already running"
		return 1
	}

	[[ "$service_command" ]] || { service_command=`which "$sname"`; }
	[[ "$service_command" ]] || {
		watchman.err "Please specify what to run with \$service_command"
	}

	[[ "$service_workdir" ]] && { cd "$service_workdir"; }

	[[ "$service_username" ]] && {
		[[ "$UID" == '0' ]] || {
			watchman.err "You can't use \$service_username if you are not root!"
			return 1
		}

		su -s "$BASH" "$service_username" -c "$service_command $service_args" &>"$service_logfile" &
	} || {
		"$service_command" $service_args &>"$service_logfile" &
	}

	service_pid="$!"
	echo "$service_pid" > "$service_tech_pidfile"

	watchman.status && {
		watchman.msg "$sname started ($service_pid)"
	} || {
		watchman.err "Failed to start $sname"
		return 1
	}

	return 0
}

watchman.stop() {
	watchman.status || {
		watchman.err "$sname doesn't seem to be running"
		return 1
	}

	local timeout='30'

	kill "$service_pid"

	ps -p "$service_pid" &>/dev/null && {
		watchman.pid_wait || {
			watchman.err "Failed to stop $sname"
			return 1
		}
	}

	watchman.msg "$sname stopped"
	return 0
}

watchman.status() {
	local rcode='1'

	[[ "$service_pid" ]] && {
		ps -p "$service_pid" &>/dev/null && { local rcode='0'; }
	}

	return "$rcode"
}

watchman.reload() {
	watchman.status || {
		watchman.err "$sname doesn't seem to be running"
		return 1
	}

	kill -HUP ${service_pid} && {
		watchman.msg "Reloading ${sname}..."
	} || {
		watchman.err "Failed to reload $sname"
		return 1
	}

	return 0
}

watchman.watch() {
	while sleep 5; do
		watchman.status || { watchman.start; }
	done
}

watchman.pid_wait() {
	local rc='0'
	echo -n "[watchman] Waiting for PID to exit: $service_pid..."

	while [[ "$counter" -lt "$timeout" ]] && { ps -p "$service_pid" &>/dev/null; }; do
		echo -n '.'
		sleep 1
		local counter=$[counter+1]
		[[ "$counter" -ge "$timeout" ]] && { echo 'timeout'; local rc='1'; }
	done

	[[ "$rc" == '1' ]] || { echo; }
	
	return "$rc"
}

watchman.depends() {
	[[ "$action" == 'start' ]] || { return 0; }

	for s in "$@"; do
		watchman "$s" status >/dev/null || {
			watchman.msg "$sname depends on $s, so starting ${s}..."
			"$0" "$s" start || {
				watchman.err "Starting $s failed, aborting."
				return 1
			}
		}
	done

	return 0
}

watchman.service_usage() {
	for i in ${service_actions[@]}; do
		type -t "$i" &>/dev/null && { _actions+="$i|"; }
	done
	watchman.msg "Usage: $sname <${_actions%|*}>"
	watchman.die 11
}

# Default functions

start() { watchman.start; }
stop() { watchman.stop; }
restart() { stop; start; }
reload() { watchman.reload; }

watch() {
	watchman.status || start
	watchman.watch
}

status() {
	watchman.status && {
		watchman.msg "$sname is running ($service_pid)"
	} || {
		watchman.msg "$sname is down"
		return 1
	}
}

# Main part

trap watchman.cleanup EXIT
watchman.init

[[ "$1" ]] || {
	watchman.usage
	watchman.die 9
}

sname=`basename $1`

action="$2"

service_logfile="$cfg_logdir/$sname.log"
service_fifo="$cfg_rundir/$sname.fifo"
service_tech_pidfile="$cfg_rundir/$sname.pid"

[[ -f "$service_tech_pidfile" ]] && { service_pid=`cat "$service_tech_pidfile"`; }

[[ "$service_actions" ]] || { service_actions=( 'start' 'stop' 'restart' 'reload' 'status' ); }

[[ -d "$cfg_cfgdir/groups/$sname" ]] && { service_type='group'; }

[[ "$service_type" ]] || { service_type='service'; }

case "$service_type" in
	group)
		group_services=( `ls "$cfg_cfgdir/groups/$sname"` )
		for i in "${group_services[@]}"; do
			[[ -h "$cfg_cfgdir/groups/$sname/$i" ]] && {
				service_script=`realpath "$cfg_cfgdir/groups/$sname/$i"`
				"$service_script" "$action" || { exitcode='1'; }
			} || {
				"$0" "$i" "$action" || { exitcode='1'; }
			}
		done
	;;

	service)
		[[ -f "$cfg_initdir/$sname" ]] && {
			source "$cfg_initdir/$sname" || {
				watchman.err "Service script exited abnormally"
				watchman.die 13
			}
		} || {
			watchman.err "$sname doesn't exist in $cfg_initdir"
			watchman.die 3
		}


		[[ "$action" ]] || { watchman.service_usage; }

		[[ "$service_pidfile" ]] && {
			[[ -f "$service_pidfile" ]] && { service_pid=`cat "$service_pidfile"`; }
		}

		type -t "$action" &>/dev/null && {
			"$action" || { exitcode='1'; }
		} || {
			watchman.err "Function $action is not defined for this service"
			watchman.die 11
		}
	;;
esac

[[ "$exitcode" ]] && { exit "$exitcode"; } || { exit 0; }
