#!/usr/bin/env bash
# Copyright (c) 2012 fbt <fbt@fleshless.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 	- Redistributions of source code must retain the above copyright notice, 
#		this list of conditions and the following disclaimer.
# 	- Redistributions in binary form must reproduce the above copyright notice,
#		this list of conditions and the following disclaimer in the
#		documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Functions

watchman.usage() {
	echo "Usage: watchman [flags] <service> <action>"
	echo "Flags:"
	echo "	-u, --user		Force user mode"
	echo "	-s, --system		Force system mode"
	echo "	-h, --help		Show this message"
}

watchman.getopt() {
	local keys

	for i in "$@"; do
		case "$i" in
			--*) echo "$i";;

			-*)
				keys=( `echo "${i##*-}" | fold -w1` )

				[[ "${#keys[@]}" -gt 1 ]] && {
					for k in ${keys[@]}; do
						echo "-${k}"
					done
				} || {
					echo "$i"
				}
			;;

			*) echo "$i";;
		esac
	done
}

watchman.args() {
	while [[ "$1" ]]; do
		case "$1" in
			-u|--user) flag_user='1';;
			-s|--system) unset flag_user;;
			-h|--help) watchman.usage; exit 0;;

			-t|--test) watchman.msg "(debug) test='$2'"; shift;;

			-*)
				watchman.err "Invalid key: $1"
				watchman.usage
				exit 1
			;;

			*) args+=( "$1" );;
		esac
		shift
	done
}

watchman.msg() { echo "[watchman] $1"; }
watchman.err() { watchman.msg "(error) $1"; }

watchman.die() { exit "$1"; }
watchman.cleanup() { true; } # Placeholder

watchman.init() {
	for i in "${cfg_init_dirs[@]}"; do
		[[ -d "$i" ]] || {
			watchman.msg "$i does not exist, attempting to create..."
			mkdir -p "$i" && {
				watchman.msg "Success!"
			} || {
				watchman.err "Can't create $i, exiting"
				watchman.die 9
			}
		}
	done

	[[ -e "$cfg_cfgdir/config.sh" ]] && { source "$cfg_cfgdir/config.sh" || return 1; }
	[[ -e "$cfg_cfgdir/config.d" ]] && {
		for i in `ls $cfg_cfgdir/config.d`; do
			source "$cfg_cfgdir/config.d/$i"
		done
	}
}

watchman.start() {
	watchman.status && {
		watchman.err "$sname is already running"
		return 1
	}

	[[ "$service_command" ]] || { service_command=`which "$sname"`; }
	[[ "$service_command" ]] || {
		watchman.err "Please specify what to run with \$service_command"
	}

	[[ "$service_workdir" ]] && { cd "$service_workdir"; }

	[[ "$service_username" ]] && {
		[[ "$UID" == '0' ]] || {
			watchman.err "You can't use \$service_username if you are not root!"
			return 1
		}

		su -s "$BASH" "$service_username" -c "$service_command $service_args" &>"$service_logfile" &
	} || {
		"$service_command" $service_args &>"$service_logfile" &
	}

	[[ "$service_pidfile" ]] && {
		[[ -f "$service_pidfile" ]] && { service_pid=`cat "$service_pidfile"`; }
	} || {
		service_pid="$!"
	}
	
	echo "$service_pid" > "$service_tech_pidfile"

	watchman.msg "$sname started ($service_pid)"

	return 0
}

watchman.stop() {
	local timeout

	watchman.status || {
		watchman.err "$sname doesn't seem to be running"
		return 1
	}

	[[ -f "$cfg_rundir/${sname}.done" ]] && {
		watchman.err "$sname is a oneshot service. You cannot stop what is already stopped."
		return 1
	}

	timeout='30'

	kill "$service_pid"

	ps -p "$service_pid" &>/dev/null && {
		watchman.pid_wait || {
			watchman.err "Failed to stop $sname"
			return 1
		}
	}

	watchman.msg "$sname stopped"
	return 0
}

watchman.status() {
	[[ -f "$cfg_rundir/${sname}.done" ]] && { return 0; }

	[[ "$service_pid" ]] && {
		ps -p "$service_pid" &>/dev/null && { return 0; }
	}

	return 1
}

watchman.reload() {
	watchman.status || {
		watchman.err "$sname doesn't seem to be running"
		return 1
	}

	kill -HUP ${service_pid} && {
		watchman.msg "Reloading ${sname}..."
	} || {
		watchman.err "Failed to reload $sname"
		return 1
	}

	return 0
}

watchman.watch() {
	while true; do
		wait "$service_pid"
		watchman.start
	done
}

watchman.pid_wait() {
	local rc='0'
	echo -n "[watchman] Waiting for PID to exit: $service_pid..."

	while [[ "$counter" -lt "$timeout" ]] && { ps -p "$service_pid" &>/dev/null; }; do
		echo -n '.'
		sleep 1
		local counter=$[counter+1]
		[[ "$counter" -ge "$timeout" ]] && { echo 'timeout'; local rc='1'; }
	done

	[[ "$rc" == '1' ]] || { echo; }
	
	return "$rc"
}

watchman.depends() {
	[[ "$action" == 'start' ]] || { return 0; }

	for s in "$@"; do
		watchman "$s" status >/dev/null || {
			watchman.msg "$sname depends on $s, so starting ${s}..."
			"$0" "$s" start || {
				watchman.err "Starting $s failed, aborting."
				return 1
			}
		}
	done

	return 0
}

watchman.service_usage() {
	for i in ${service_actions[@]}; do
		type -t "$i" &>/dev/null && { _actions+="$i|"; }
	done
	watchman.msg "Usage: $sname <${_actions%|*}>"
	watchman.die 11
}

watchman.done() { touch "$cfg_rundir/${sname}.done"; }

# Default functions

start() { watchman.start; }
stop() { watchman.stop; }
restart() { stop; start; }
reload() { watchman.reload; }

watch() {
	watchman.status && {
		watchman.err "$sname is already running ($service_pid)"
		return 1
	}

	start
	watchman.watch
}

status() {
	watchman.status && {
		watchman.msg "$sname is running ($service_pid)"
	} || {
		watchman.msg "$sname is down"
		return 1
	}
}

trap watchman.cleanup EXIT

# Arguments and options:

[[ "$UID" == '0' ]] || { flag_user='1'; }

watchman.args `watchman.getopt "$@"` || exit 13

[[ "$flag_user" ]] && {
	cfg_cfgdir="$HOME/.watchman"
	cfg_tmpdir="/tmp/$USER/watchman"
} || {
	cfg_cfgdir='/etc/watchman'
	cfg_tmpdir='/run/watchman'
}

cfg_rundir="$cfg_tmpdir/run"
cfg_initdir="$cfg_cfgdir/init.d"
cfg_logdir="$cfg_tmpdir/log"

cfg_init_dirs+=( "$cfg_cfgdir" )
cfg_init_dirs+=( "$cfg_tmpdir" )
cfg_init_dirs+=( "$cfg_rundir" )
cfg_init_dirs+=( "$cfg_initdir" )
cfg_init_dirs+=( "$cfg_logdir" )
cfg_init_dirs+=( "$cfg_cfgdir/groups/all" )

# Main:

watchman.init

[[ "${args[0]}" ]] || {
	watchman.usage
    watchman.die 9
}

sname=`basename ${args[0]}`

action="${args[1]}"

service_logfile="$cfg_logdir/$sname.log"
service_fifo="$cfg_rundir/$sname.fifo"
service_tech_pidfile="$cfg_rundir/$sname.pid"

[[ -f "$service_tech_pidfile" ]] && { service_pid=`cat "$service_tech_pidfile"`; }

[[ "$service_actions" ]] || { service_actions=( 'start' 'stop' 'restart' 'reload' 'status' ); }

[[ -d "$cfg_cfgdir/groups/$sname" ]] && { service_type='group'; }

[[ "$service_type" ]] || { service_type='service'; }

case "$service_type" in
	group)
		group_services=( `ls "$cfg_cfgdir/groups/$sname"` )

		[[ "$group_services" ]] || {
			[[ "$sname" == 'all' ]] && { group_services=( `ls "$cfg_initdir"` ); }
		}

		[[ "$group_services" ]] || {
			watchman.err "No services in group $sname"
			watchman.die 15
		}

		for i in "${group_services[@]}"; do
			[[ -h "$cfg_cfgdir/groups/$sname/$i" ]] && {
				service_script=`realpath "$cfg_cfgdir/groups/$sname/$i"`
				"$service_script" "$action" || { exitcode='1'; }
			} || {
				"$0" "$i" "$action" || { exitcode='1'; }
			}
		done
	;;

	service)
		[[ -f "$cfg_initdir/$sname" ]] && {
			source "$cfg_initdir/$sname" || {
				watchman.err "Service script exited abnormally"
				watchman.die 13
			}
		} || {
			watchman.err "$sname doesn't exist in $cfg_initdir"
			watchman.die 3
		}


		[[ "$action" ]] || { watchman.service_usage; }

		[[ "$service_pidfile" ]] && {
			[[ -f "$service_pidfile" ]] && { service_pid=`cat "$service_pidfile"`; }
		}

		type -t "$action" &>/dev/null && {
			"$action" || { exitcode='1'; }
		} || {
			watchman.err "Function $action is not defined for this service"
			watchman.die 11
		}
	;;
esac

[[ "$exitcode" ]] && { exit "$exitcode"; } || { exit 0; }
